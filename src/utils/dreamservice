const axios = require('axios')
const url = require('url')
const gsearch = require('./gsearch')

const DREAM_SERVICE_URL ='https://cs361-parsely-rjg4g6kr7q-uw.a.run.app' // my service
const WIKI_SCRAPER_URL = 'https://wiki-scraper-331405.uc.r.appspot.com' // David Ju's service
const GRAPH_SERVICE_URL = 'https://analytics-app-361.herokuapp.com/graphs_ms' // Spencer Wagner's service


async function getDreamData(text) {
    try {
        const response = await axios.post(DREAM_SERVICE_URL + '/dream', { text: text })

        // pick settings and number of images per request
        const longSettings = response.data.settings
        let settingList = pickSettings(response.data.sub_settings)
        let numImages = 2
        if (settingList.length === 2) {
            numImages = 3
        } else if (settingList.length === 1) {
            numImages = 6
        }

        // get the setting images from Alex's service
        const settingImages = await gsearch.getGoogleImages(settingList, numImages)
        console.log(settingImages)
        
        // build the graphs/plots
        const sentimentData = response.data.sentiment
        const shadowData = getShadowData(response.data.sentiment)

        // format graph data
        const sentimentScatterPlot = formatSentimentData(sentimentData, graph_types.general_sentiment)
        const shadowScatterPlot = formatSentimentData(shadowData, graph_types.shadow)
        const docPiePlots = formatDocPieData(response.data.doc_sentiment, graph_types.doc_graphs)
        
        // send the data to Spencer's service
        const sentimentGraphFile = await getGraph(sentimentScatterPlot)
        const shadowGraphFile = await getGraph(shadowScatterPlot)
        const docPolarityPieFile = await getGraph(docPiePlots.doc_polarity)
        const docEmotionPieFile = await getGraph(docPiePlots.doc_emotion)
        
        // go get references for symbols
        let symbolList = shuffleSymbols(response.data.symbols)
        symbolList = symbolList.filter(s => s != 'dream')

        // call David's service
        const symbolsResponse = await getWikipediaData(symbolList)
        const symbols = createSymbolObjs(symbolsResponse)

        // get shadow words
        var shadowList = []
        for (let i = 0; i < shadowData.length; i++) {
            shadowList.push(shadowData[i][0])
        }
               
        // build the return object for the template context
        const dream = {
            setting: {
                text: [longSettings],
                photos: settingImages
            },
            symbols: {
                list: symbols
            },
            characters: {
                dreamego: response.data.ego,
                figures: response.data.characters
            },
            shadow: {
                words: shadowList,
                meter: shadowGraphFile
            },
            sentiment: {
                scatter: sentimentGraphFile,
                polarity: docPolarityPieFile,
                emotion: docEmotionPieFile
            }
        }    
        return dream

    } catch (error) {
        console.log(error)
    }
}

/* -------   Setting Content Helper Functions  -------- */
function pickSettings(list) {
    // get settings that have more description (whitespace)
    var descriptive = []
    for (let i = 0; i < list.length; i++) {
        if (list[i].includes(' ')) {
            descriptive.push(list[i]) // add to descriptive
        }
    }

    // if there are fewer than 3 descriptive settings, grab more to make up 3     
    if (descriptive.length < 3) {
         // first, remove already taken from the list
         // help from: https://stackoverflow.com/questions/19957348/remove-all-elements-contained-in-another-array
        list = list.filter((item) => !descriptive.includes(item))

        var shuffledList = list.sort(() => 0.5 - Math.random())

        // add psuedo-random settings
        while (descriptive.length < 3) {
            descriptive.push(shuffledList.pop())
        }
    }

    // if there are more than 3, take out some descriptions
    if (descriptive.length > 3) {
        descriptive.sort(() => 0.5 - Math.random())
        while (descriptive.length > 3) {
            descriptive.pop()
        }
    }

    return descriptive
}



/* -------   Graph Content Helper Functions  -------- */
graph_types = {
    general_sentiment:  {
        graph_type: "scatter",
        colors: "RdBu",
        xaxis: "polarity",
        yaxis: "subjectivity",
        xlabel: "Polarity: Negative to Positive",
        ylabel: "Emotional Intensity",
        title: "Dream Sentiment"
    },
    doc_graphs: {
        doc_polarity:  {
            graph_type: "pie",
            colors: "Greys",
            xaxis: "polarity",
            yaxis: "proportion",
            xlabel: "",
            ylabel: "",
            title: "Polarity: Positive to Negative"
        },
        doc_emotion:  {
            graph_type: "pie",
            colors: "Purples",
            xaxis: "subjectivity",
            yaxis: "proportion",
            xlabel: "",
            ylabel: "",
            title: "Emotion"
        }
    },
    shadow:  {
        graph_type: "scatter",
        colors: "gray",
        xaxis: "polarity",
        yaxis: "subjectivity",
        xlabel: "Polarity: Negative to Positive",
        ylabel: "Emotional Intensity",
        title: "Shadow Sentiment"
    },

}

function getShadowData(data) {
    const shadow = []
    for (let i = 0; i < data.length; i++) {
        if (data[i][1] < 0) {
            shadow.push(data[i])
        }
    }
    return shadow
}

// graphObj = { graph_type, colors, xaxis, yaxis, xlabel, ylabel, title }
function formatSentimentData(data, graphObj, pol=1, subj=2) {
    table = []
    for (let i = 0; i < data.length; i++) {
        point = {
            polarity: data[i][pol],
            subjectivity: data[i][subj]
        }
        table.push(point)
    }
    graphObj.table = table
    
    return graphObj
}

function formatDocPieData(data, graphObjs) {
    let [pos, neg] = [0, 0]
    
    let polarity = Math.round(data[0] * 100)
    if (polarity < 0) {
        pos = 200 - (Math.abs(polarity) + 100)
        neg = 200 - pos
    } else {
        pos = polarity + 100
        neg = 200 - pos
    }
    polarity_table = [
        {
            polarity: "positive",
            proportion: pos
        },
        {
            polarity: "negative",
            proportion: neg
        }
    ]
    emotion_proportion = Math.round(data[1] * 100)
    emotion_table = [
        {
            subjectivity: "neutral",
            proportion: 100 - emotion_proportion 
        },
        {
            subjectivity: "emotion",
            proportion: emotion_proportion
        }
    ]
    graphObjs.doc_polarity.table = polarity_table
    graphObjs.doc_emotion.table = emotion_table

    return graphObjs 
}

/* SPENCER's Graphing microservice call */
async function getGraph(graphObj) {

    return await axios.post(GRAPH_SERVICE_URL, graphObj)
        .then((res) => {
            return res.data
        }).catch ((error) => {
            console.log(error.response.status)
        }) 
}

/* -------   Symbol Content Helper Functions  -------- */
// return a sublist of 6 random symbols
function shuffleSymbols(list) {
    if (list.length <= 6) {
        return list
    } else {
        const shuffledList = list.sort(() => 0.5 - Math.random())
        return shuffledList
    }
}

function createSymbolObjs(symbolsWikiDataList) {
    var list = []

    for (let i = 0; i < symbolsWikiDataList.length; i++) {

        // create an object for each symbol in the list
        let summary = null
        let image = null
        const data = symbolsWikiDataList[i][0].data
        if (data.hasOwnProperty('summary')) {
            summary = data.summary
            image = symbolsWikiDataList[i][1].data.image_url
        } else {
            image = data.image
            summary = symbolsWikiDataList[i][1].data.summary
        }

        const obj = {
            id: i,
            name: data.title,
            image: image,
            text: summary
        }

        list.push(obj)
    }
    return list
}

function buildWikiLinks(symbol) {
    function buildUrl(element, type) {
        return WIKI_SCRAPER_URL  + '/' + element + '/' + type
    }
    // replace spaces in symbol text; help from: https://stackoverflow.com/questions/441018/replacing-spaces-with-underscores-in-javascript
    symbol.split(' ').join('%20')
   
    const summary = buildUrl(symbol, 'summary')
    const img = buildUrl(symbol, 'image')

    return [summary, img]
}

/* DAVID's Microservice Calls */
async function getWikipediaData(symbolList) {
  
    const maxSymbols = 6
    if (symbolList.length < 6) {
        maxSymbols = symbolList.length
    }
    // loop requests until there are 6 complete symbols OR until list runs out
    var responseList = []
    let count = 0
    while (symbolList.length > 0 && count < maxSymbols) {

        const next = symbolList.pop()

        // create the image and summary request urls
        const links = buildWikiLinks(next)

        // send the urls
        const response = await axios.all(links.map(l => axios.get(l)))
            .then(axios.spread(function (...res) {
                responseList.push(res)
                count ++
                // console.log(res[0].data)
                // console.log(res[1].data)
                return
            })).catch ((error) => {
                console.log(error.response.status)
            })
    }   
    return responseList         
}


module.exports = {
    getDreamData: getDreamData
}